var utilities = require('utilities');

var Exploit = function (room, flagName) {
    var flag = Game.flags[flagName];
    var roomName = flag.pos.roomName;
    this.units = {};
    this.name = roomName;
    this.roomName = roomName;
    this.flag = flag;

    this.sourceRoom = room;

    // Prepare memory
    if (!Memory.exploits) {
        Memory.exploits = {};
    }
    if (!Memory.exploits[roomName]) {
        Memory.exploits[roomName] = {};
    }

    this.memory = Memory.exploits[roomName];

    // Adjust flag color.
    if (this.flag.color != COLOR_RED) {
        this.flag.setColor(COLOR_RED);
    }

    // Collect creeps from temp data.
    if (Game.exploitTemp && Game.exploitTemp[this.name]) {
        for (let i in Game.exploitTemp[this.name]) {
            let creep = Game.getObjectById(Game.exploitTemp[this.name][i]);

            if (!this.units[creep.memory.exploitUnitType]) {
                this.units[creep.memory.exploitUnitType] = [];
            }
            this.units[creep.memory.exploitUnitType].push(creep);
        }
    }

    // Collect source keeper lair positions.
    if (!this.memory.lairs && Memory.rooms[this.roomName] && Memory.rooms[this.roomName].intel) {
        let intel = Memory.rooms[this.roomName].intel;
        let lairs = intel.structures[STRUCTURE_KEEPER_LAIR];
        if (lairs) {
            this.memory.lairs = {};
            for (let id in lairs) {
                this.memory.lairs[id] = {
                    paths: {},
                };

                // @todo Also save associated resources.
            }
        }
    }

    // Collect sources belonging to lairs.
    if (this.memory.lairs && !this.memory.sourcesChecked || this.memory.sourcesChecked < Game.time - 6542) {
        let found = false;
        for (let id in this.memory.lairs) {
            let lair = Game.getObjectById(id);
            if (!lair) break;

            // Check sources.
            var sources = lair.pos.findInRange(FIND_SOURCES, 7);
            if (sources.length < 1) {
                sources = lair.pos.findInRange(FIND_MINERALS, 7);
            }
            for (let i in sources) {
                this.memory.lairs[id].source = sources[i].id;
                this.memory.lairs[id].sourceType = sources[i].mineralType || RESOURCE_ENERGY;
                break;
            }

            found = true;
        }

        if (found) {
            this.memory.sourcesChecked = Game.time;
        }
    }

    // Cache paths around the room.
    this.calculatePaths();

    // Save closest lair to entrance point.
    if (this.memory.lairs && this.memory.pathToRoom && !this.memory.closestLairToEntrance) {
        let lastPos = utilities.decodePosition(this.memory.pathToRoom[this.memory.pathToRoom.length - 1]);
        let bestRange = null;
        let best = null;
        for (let id in this.memory.lairs) {
            let lair = Game.getObjectById(id);
            if (lair && (!best || lastPos.getRangeTo(lair) < bestRange)) {
                best = id;
                bestRange = lastPos.getRangeTo(lair);
            }
        }

        if (best) {
            this.memory.closestLairToEntrance = best;
        }
    }

    // Try and build roads where needed.
    this.buildRoads();
};

Exploit.prototype.buildRoads = function () {
    if (!this.memory.lastRoadCheck || this.memory.lastRoadCheck < Game.time - 51 && _.size(Game.constructionSites) < 75) {
        if (Game.rooms[this.roomName]) {
            let room = Game.rooms[this.roomName];
            let sites = room.find(FIND_CONSTRUCTION_SITES);
            let numSites = sites.length;
            this.memory.lastRoadCheck = Game.time;

            if (this.memory.pathToRoom) {
                for (let i in this.memory.pathToRoom) {
                    if (numSites >= 10) return;
                    let pos = utilities.decodePosition(this.memory.pathToRoom[i]);
                    if (pos.roomName != this.roomName) continue;

                    let structures = pos.lookFor(LOOK_STRUCTURES);
                    let sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

                    if (structures.length > 0 || sites.length > 0) continue;
                    if (pos.createConstructionSite(STRUCTURE_ROAD) == OK) {
                        numSites++;
                    }
                }
            }

            if (this.memory.lairs) {
                for (id in this.memory.lairs) {
                    if (this.memory.lairs[id].sourcePath) {
                        let path = this.memory.lairs[id].sourcePath.path;
                        for (let i in path) {
                            if (numSites >= 10) return;
                            let pos = utilities.decodePosition(path[i]);

                            let structures = pos.lookFor(LOOK_STRUCTURES);
                            let sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

                            if (sites.length > 0) continue;
                            if (_.filter(structures, (s) => s.structureType == STRUCTURE_ROAD).length == 0) {
                                if (pos.createConstructionSite(STRUCTURE_ROAD) == OK) {
                                    numSites++;
                                }
                            }

                            // Build containers close to sources.
                            if (i == path.length - 2 && _.filter(structures, (s) => s.structureType == STRUCTURE_CONTAINER).length == 0) {
                                if (pos.createConstructionSite(STRUCTURE_CONTAINER) == OK) {
                                    numSites++;
                                }
                            }
                        }
                    }

                    for (id2 in this.memory.lairs) {
                        if (this.memory.lairs[id].paths[id2] && this.memory.lairs[id].paths[id2].path) {
                            let path = this.memory.lairs[id].paths[id2].path;
                            for (let i in path) {
                                if (numSites >= 10) return;
                                let pos = utilities.decodePosition(path[i]);

                                let structures = pos.lookFor(LOOK_STRUCTURES);
                                let sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);

                                if (structures.length > 0 || sites.length > 0) continue;
                                if (pos.createConstructionSite(STRUCTURE_ROAD) == OK) {
                                    numSites++;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};

Exploit.prototype.calculatePaths = function () {
    // Calculate path into room.
    if (!this.memory.pathToRoom || !this.memory.pathToRoomCalculated || this.memory.pathToRoomCalculated < Game.time - 10000) {
        var startPosition = this.sourceRoom.getStorageLocation();
        startPosition = new RoomPosition(startPosition.x, startPosition.y, this.sourceRoom.name);
        if (this.sourceRoom.storage) {
            startPosition = this.sourceRoom.storage.pos;
        }

        var endPosition = new RoomPosition(25, 25, this.flag.pos.roomName);

        var result = utilities.getPath(startPosition, {pos: endPosition, range: 20});

        if (result) {
            //console.log('found path in', result.ops, 'operations', result.path);

            this.memory.pathToRoom = utilities.serializePositionPath(result.path);
            this.memory.pathToRoomCalculated = Game.time;
            delete this.memory.closestLairToEntrance;
        }
        else {
            console.log('No path found!');
        }
        return;
    }

    for (let id in this.memory.lairs) {
        // Calculate paths between source keeper lairs.
        for (let id2 in this.memory.lairs) {
            if (id == id2) continue;
            if (this.memory.lairs[id].paths[id2]) continue;

            var lair = Game.getObjectById(id);
            var lair2 = Game.getObjectById(id2);

            if (!lair || !lair2) continue;

            var result = utilities.getPath(lair.pos, {pos: lair2.pos, range: 1});

            if (result) {
                this.memory.lairs[id].paths[id2] = {
                    path: utilities.serializePositionPath(result.path),
                    lastCalculated: Game.time,
                };
                this.memory.lairs[id2].paths[id] = {
                    reverse: true,
                    lastCalculated: Game.time,
                };
            }
            else {
                console.log('No path found!');
            }
            return;
        }

        // Calculate paths between lairs and actual sources.
        if (this.memory.lairs[id].source && !this.memory.lairs[id].sourcePath) {
            var lair = Game.getObjectById(id);
            var source = Game.getObjectById(this.memory.lairs[id].source);

            if (!lair || !source) continue;

            var result = utilities.getPath(lair.pos, {pos: source.pos, range: 1});

            if (result) {
                this.memory.lairs[id].sourcePath = {
                    path: utilities.serializePositionPath(result.path),
                    lastCalculated: Game.time,
                };
            }
            else {
                console.log('No path found!');
            }
            return;
        }
    }
};

Exploit.prototype.addSpawnOptions = function (options) {
    // Spawn a guardian that travels around the room to keep sources safe.
    let numGuardians = 0;
    if (this.units.guardian) {
        for (let i in this.units.guardian) {
            let creep = this.units.guardian[i];

            // Only counts if it has longer to live than it takes us to respawn and get a new creep there.
            if (!creep.ticksToLive || creep.ticksToLive > _.size(creep.body) * 3 + _.size(this.memory.pathToRoom) + 50) {
                numGuardians++;
            }
        }
    }

    if (numGuardians < 1) {
        // @todo Spawn in time to arrive when previous guardian expires.
        // @todo Only spawn guardian if room is protected by source keepers.
        options.push({
            role: 'exploit',
            priority: 3,
            weight: 1,
            subRole: 'guardian',
            exploit: this.name,
        });
    }

    // When necessary, spawn a builder to create a road network and containers.
    let numSites = _.size(_.filter(Game.constructionSites, (site) => site.pos.roomName == this.roomName));
    let maxBuilders = Math.ceil(numSites / 7);

    if (maxBuilders <= 0) {
        // Send a builder if containers are decaying too much.
        if (this.memory.lairs) {
            for (let id in this.memory.lairs) {
                let source = Game.getObjectById(this.memory.lairs[id].source);
                if (source) {
                    let container = source.getNearbyContainer();
                    if (container && container.hits < container.hitsMax * 0.5) {
                        maxBuilders = 1;
                        break;
                    }
                }
            }
        }
    }

    if (numSites > 0 && _.size(_.filter(this.units['builder'], (creep) => creep.ticksToLive && creep.ticksToLive > _.size(creep.body) * 3 + _.size(this.memory.pathToRoom) + 50)) < maxBuilders) {
        // @todo Maybe even spawn 2 builders when roads are still being built, but only use 1 when doing repairs.
        options.push({
            role: 'exploit',
            priority: 3,
            weight: 0.5,
            subRole: 'builder',
            exploit: this.name,
        });
    }

    // Once containers are build, send harvesters.
    if (this.memory.lairs) {
        let activeLairs = 0;
        let activeLairPathLength = 0;
        let roomPathLength = _.size(this.memory.pathToRoom);

        for (let id in this.memory.lairs) {
            let source = Game.getObjectById(this.memory.lairs[id].source);
            if (!source || !source.getNearbyContainer()) continue;

            // Regenerating mineral sources are also considered inactive.
            if (source.mineralType && source.mineralAmount <= 0) continue;

            activeLairs++;
            activeLairPathLength += roomPathLength;
            if (id != this.memory.closestLairToEntrance) {
                let id2 = this.memory.closestLairToEntrance;
                if (this.memory.lairs[id].paths[id2]) {
                    activeLairPathLength += _.size(this.memory.lairs[id].paths[id2].path);
                    activeLairPathLength += _.size(this.memory.lairs[id2].paths[id].path);
                }
            }

            let numHarvesters = 0;
            if (this.units.harvester) {
                numHarvesters += _.filter(this.units.harvester, (creep) => creep.memory.fixedSource == source.id && (!creep.ticksToLive || creep.ticksToLive > _.size(creep.body) * 3 + _.size(this.memory.pathToRoom) + 20)).length;
            }

            if (numHarvesters < 1) {
                options.push({
                    role: 'exploit',
                    priority: 3,
                    weight: 0.1,
                    subRole: 'harvester',
                    exploit: this.name,
                    source: source.id,
                    resourceType: source.mineralType || RESOURCE_ENERGY,
                });
            }
        }

        //console.log('Total path length for exploits:', activeLairPathLength);
        let production = activeLairs * 4500 / 300;
        let productionAfterRoundTrip = 2 * activeLairPathLength * production;
        //console.log(productionAfterRoundTrip / 50, 'carry parts needed for the whole exploit operation.');
        let neededWorkParts = productionAfterRoundTrip / 50;

        let totalWorkParts = 0;
        if (this.units.hauler) {
            for (let i in this.units.hauler) {
                totalWorkParts += this.units.hauler[i].memory.body.carry || 0;
            }
        }
        //console.log('total work parts on route:', totalWorkParts, '/', neededWorkParts * 0.3);

        let maxHaulers = activeLairs; // @todo Calculate based on path lengths, number of carry parts, etc.
        let numHaulers = _.size(this.units.hauler);
        if (totalWorkParts < neededWorkParts * 0.5) { // Conservative for now.
            options.push({
                role: 'exploit',
                priority: 3,
                weight: 0,
                subRole: 'hauler',
                exploit: this.name,
            });
        }
    }
};

Exploit.prototype.spawnUnit = function (spawn, option) {
    if (option.subRole == 'guardian') {
        spawn.createManagedCreep({
            role: 'brawler',
            body: [
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE,
                MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
                ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
                ATTACK, ATTACK, ATTACK, ATTACK, MOVE, HEAL, HEAL, HEAL, HEAL, HEAL
            ],
            memory: {
                exploitName: this.name,
                exploitUnitType: 'guardian',
            },
        });
    }
    else if (option.subRole == 'builder') {
        spawn.createManagedCreep({
            role: 'builder.exploit',
            bodyWeights: {move: 0.4, carry: 0.3, work: 0.3},
            memory: {
                exploitName: this.name,
                exploitUnitType: 'builder',
            },
        });
    }
    else if (option.subRole == 'harvester') {
        let config = {
            role: 'harvester.exploit',
            bodyWeights: {move: 0.35, carry: 0.15, work: 0.5},
            memory: {
                exploitName: this.name,
                exploitUnitType: 'harvester',
                fixedSource: option.source,
            },
        };

        if (option.resourceType == RESOURCE_ENERGY) {
            config.maxParts = {work: 9};
        }

        spawn.createManagedCreep(config);
    }
    else if (option.subRole == 'hauler') {
        spawn.createManagedCreep({
            role: 'hauler.exploit',
            bodyWeights: {move: 0.35, carry: 0.65},
            //maxParts: {carry: 20},
            memory: {
                exploitName: this.name,
                exploitUnitType: 'hauler',
            },
        });
    }

    return true;
};

module.exports = Exploit;
