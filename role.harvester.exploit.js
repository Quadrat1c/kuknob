var utilities = require('utilities');

/**
 * Makes the creep gather resources in the current room.
 */
Creep.prototype.performExploitHarvest = function () {
    var creep = this;
    var source = Game.getObjectById(creep.memory.fixedSource);
    var container = source.getNearbyContainer();

    if (source.isDangerous()) {
        var safeSpot = new RoomPosition(25, 25, this.room.name);
        if (this.pos.getRangeTo(safeSpot) > 5) {
            this.moveToRange(safeSpot, 5);
        }
        return;
    }

    if (!container || _.sum(container.store) < container.storeCapacity) {
        // Pick up nearby resources and put in container.
        let dropped = this.pos.findInRange(FIND_DROPPED_RESOURCES, 5, {
            filter: (resources) => container || resources.resourceType == RESOURCE_ENERGY
        });
        if (dropped.length > 0) {
            if (creep.pos.getRangeTo(dropped[0]) > 1) {
                creep.moveToRange(dropped[0], 1);
            }
            else {
                var result = creep.pickup(dropped[0]);
            }
            return true;
        }
    }

    if (creep.pos.getRangeTo(source) > 1) {
        creep.moveTo(source);
    }
    else {
        var result = creep.harvest(source);
    }

    // If there's a container nearby, directly deposit energy.
    if (_.sum(creep.carry) > creep.carryCapacity * 0.5) {
        if (container && creep.pos.getRangeTo(container) <= 1) {
            for (let resourceType in this.carry) {
                if (this.carry[resourceType] <= 0) continue;
                creep.transfer(container, resourceType);
                break;
            }
        }
    }

    return true;
};

/**
 * Dumps minerals a harvester creep has gathered.
 */
Creep.prototype.performExploitHarvesterDeliver = function () {
    var source = Game.getObjectById(this.memory.fixedSource);
    var container = source.getNearbyContainer();

    // By default, deliver to nearby container if there's space.
    // @todo Deliver anything, not just what the source provides.
    if (container && _.sum(container.store) < container.storeCapacity) {
        if (this.pos.getRangeTo(container) > 1) {
            this.moveTo(container);
        }
        else {
            for (let resourceType in this.carry) {
                if (this.carry[resourceType] <= 0) continue;
                this.transfer(container, resourceType);
                break;
            }
        }
    }
    else {
        // Just drop it. Somebody will pick it up. Maybe.
        this.drop(source.mineralType || RESOURCE_ENERGY);
    }

    return true;
};

/**
 * Puts this creep into or out of harvesting mode.
 */
Creep.prototype.setHarvesterState = function (harvesting) {
    this.memory.harvesting = harvesting;
    delete this.memory.resourceTarget;
    delete this.memory.tempRole;
};

/**
 * Makes a creep behave like an exploit harvester.
 */
Creep.prototype.runExploitHarvesterLogic = function () {
    if (!this.memory.harvesting && _.sum(this.carry) <= 0) {
        this.setHarvesterState(true);
    }
    else if (this.memory.harvesting && _.sum(this.carry) >= this.carryCapacity) {
        this.setHarvesterState(false);
    }

    var exploit = Game.exploits[this.memory.exploitName];
    if (exploit) {
        // Follow cached path when requested.
        if (this.hasCachedPath()) {
            this.followCachedPath();
            if (this.hasArrived()) {
                this.clearCachedPath();
                if (this.memory.travellingToRoom) {
                    // Next, travel to destined source.
                    let closest = exploit.memory.closestLairToEntrance;
                    let source = Game.getObjectById(this.memory.fixedSource);
                    if (closest && source && exploit.memory.lairs[closest]) {
                        let lair = source.getNearbyLair();
                        if (lair) {
                            let target = lair.id;
                            let path = exploit.memory.lairs[closest].paths[target];
                            if (path) {
                                if (path.path) {
                                    this.setCachedPath(exploit.memory.lairs[closest].paths[target].path, false, 3);
                                }
                                else {
                                    this.setCachedPath(exploit.memory.lairs[target].paths[closest].path, true, 3);
                                }
                            }
                        }
                    }

                    delete this.memory.travellingToRoom;
                }
            }
            else {
                return true;
            }
        }
        else if (this.pos.roomName != exploit.roomName && exploit.memory.pathToRoom) {
            this.setCachedPath(exploit.memory.pathToRoom, false, 3);
            this.memory.travellingToRoom = true;
            return true;
        }
    }

    // Make sure to keep nearby container repaired.
    var source = Game.getObjectById(this.memory.fixedSource);
    var container = source.getNearbyContainer();

    if (this.carry.energy > 0) {
        if (!container) {
            // If a construction site for a container is nearby, help build it to recover.
            let sites = this.pos.findInRange(FIND_CONSTRUCTION_SITES, 3, {
                filter: (site) => site.structureType == STRUCTURE_CONTAINER
            });
            if (sites.length > 0 && this.carry.energy >= (this.memory.body.work || 0) * 5) {
                this.build(sites[0]);
                return;
            }
        }
        else if (container.hits < container.hitsMax * 0.2 && !source.isDangerous() && this.carry.energy >= (this.memory.body.work || 0)) {
            if (this.pos.getRangeTo(container) > 3) {
                this.moveTo(container);
            }
            else {
                this.repair(container);
            }
            return;
        }
    }

    if (this.memory.harvesting) {
        return this.performExploitHarvest();
    }
    else {
        return this.performExploitHarvesterDeliver();
    }
};
